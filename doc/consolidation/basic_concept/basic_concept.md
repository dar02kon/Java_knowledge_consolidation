# Java基础概念

## 什么是Java？

Java是Sun Microsystems 于1995年首次发布的编程语言和计算平台

计算平台是计算机系统硬件与软件的设计和开发的基础。具有一定的标准性和公开性，同时也决定了该计算机系统的硬件与软件的性能。硬件的基础是中央处理器（CPU ），软件的基础是操作系统。因此，通常用作为计算机系统 CPU 的某种处理机类型和该系统使用的操作系统，即处理机/操作系统来表征计算平台。

同人类任何语言一样，Java 为我们提供了一种表达思想的方式。如操作得当，同其他方式相比，随着问题变 得愈大和愈复杂，这种表达方式的方便性和灵活性会显露无遗。 不可将 Java 简单想象成一系列特性的集合；如孤立地看，有些特性是没有任何意义的。只有在考虑“设 计”、而非考虑简单的编码时，才可真正体会到Java 的强大。

## Java程序是怎么运行的

在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，**JVM**负责将字节码翻译成特定平台下的机器码并运行。

### JDK与JRE

JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。是一个编写Java的Applet小程序和应用程序的程序开发环境。它包含了Java运行时环境（JRE）和一些Java工具如：Java的编译器（javac.exe），Java解释执行器（java.exe）和Java基础类库（有3000多类，常用的类150多个）。

JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 核心类库与其所支持的文件。但是，它不能用于创建新程序。因为它不包含开发工具——编译器，调试器和其他工具。

### JVM

JVM(java Virtual Machine ) ，Java虚拟机，Java运行环境。Java虚拟机，是一种虚拟出来的计算机，是通过在实际的计算机上模拟仿真各种计算机功能来实现的。JVM是使用C/C++编写的（反正不可能是用Java写的）

JVM 有针对不同系统的特定实现（Windows，Linux，macOS），同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。

**JVM 并不是只有一种只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。** 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。

### 字节码与机器码

Java字节码是Java虚拟机（JVM）执行的一种虚拟指令格式。字节码是面向JVM的而不是面向任何特定的处理器，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

机器码指的是软件根据计算机的硬件信息，例如CPU、内存、主板序列号等，按照一定的算法生成的一串无规律的字符串，并且在不同计算机上生成的机器码是不一样的，因为每台计算机的硬件信息不一样。

一个JAVA程序通过javac编译成字节码以后，在执行的时候，由JVM将字节码编译成本地机器码，然后再执行。

在 HotSpot 虚拟机内置了两个即时编译器，分别称为 Client Compiler 和Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，即C1 编译模式，C2 编译模式（习惯性称呼）。

C1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。而 C2 编译模式，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

* 转译器

  转译器将每个Java指令都转译成对等的微处理器指令，并根据转译后的指令先后次序依序执行，由于一个Java指令可能被转译成十几或数十几个对等的微处理器指令，这种模式执行的速度相当缓慢。

* JIT

  Java代码开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，其实Java本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。

* AOT

  AOT 编译器的基本思想是：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码，简单来说就是从源代码转化为机器码。本地代码（native code）是计算机编程（代码），编译用来运行一个特殊的处理器。但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量。例如 Java 语言中的动态类加载，因为 AOT 是在程序运行前编译的，所以无法获知这一信息，所以会导致一些问题的产生。AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略。就如 JVM 其运行模式中选择 Mixed 混合模式一样，使用 C1 编译模式只进行简单的优化，而 C2 编译模式则进行较为激进的优化。充分利用两种模式的优点，从而达到最优的运行效率。

在原始的 Java 解释器中，解释过的 Java 会比C 慢上 20 到 50 倍。尽管经过长时间的发展，这个速度有一定程度的提高，但和C 比起来仍然很悬殊。计算机最注重的就是速度；假如在一台计算机 上不能明显较快地干活，那么还不如用手做（有人建议在开发期间使用Java，以缩短开发时间。然后用一个 工具和支撑库将代码转换成C++，这样可获得更快的执行速度）。 为使Java 适用于大多数Web 开发项目，关键在于速度上的改善。此时要用到人们称为“刚好及时”（Just In Time，即JIT）的编译器，甚至考虑更低级的代码编译器。

当然，低级代码编译器会使编译好的程序不能跨平台执行，但同时也带来了速度上的提升。这个速度甚至接近 C 和 C++。 而且Java 中的程序交叉编译应当比C 和 C++中简单得多（理论上只需重编译即可，但实际仍较难实现；其他语言也曾作出类似的保证）

### JVM调优简单介绍

**对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。**

GC就是Java的垃圾回收机制，通常来说，GC主要针对的是堆(java heap)区，JVM对于堆的垃圾回收，采用分代收集的策略，所以分代的原理就是根据堆中对象的存活周期进行分代，年轻代中，每次垃圾回收都有大批对象死去，只有少量存活，而老年代中存放的对象存活率高。

* Young space：年轻代(新生代)，保存生命周期较短的对象
* Tenured space：老年代(年老代)，保存生命周期较长的对象
* Minor GC：发生在Young space中的gc
* Major GC：发生在老年代Tenured space中的gc
* STW(stop the world)：指的是用户线程在运行至安全点(safe point)或安全区域(safe region)之后，就自行挂起，进入暂停状态，对外的表现就是卡顿，而不论何种gc算法，不论是minor gc还是major gc都会STW，区别只在于STW的时间长短。
* Full GC：无官方定义，通常意义上而言指的是一次特殊GC的行为描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等。

**几个评估GC性能的指标**

* 吞吐量      应用花在非GC上的时间百分比 
* GC负荷    与吞吐量相反，指应用花在GC上的时间百分比 
* 暂停时间   应用花在GC stop-the-world 的时间 
* GC频率     顾名思义 
* Footprint   一些资源大小的测量，比如堆的大小 
* 反应速度   从一个对象变成垃圾道这个对象被回收的时间 

一个交互式的应用要求暂停时间越少越好，然而，一个非交互性的应用，当然是希望GC负荷越低越好。

 一个实时系统对暂停时间和GC负荷的要求，都是越低越好。

一个嵌入式系统当然希望Footprint越小越好。

**导致Full GC的原因**

* 年老代（Tenured）被写满

  调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 

* 持久代Pemanet Generation空间不足

  增大Perm Gen空间，避免太多静态对象 ， 控制好新生代和旧生代的比例

* System.gc()被显示调用

  垃圾回收不要手动触发，尽量依靠JVM自身的机制

## 面向对象

面向对象编程（OOP）具有多方面的吸引力。对管理人员，它实现了更快和更廉价的开发与维护过程。对分析 与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。对程序员，对象模型显得如此高 雅和浅显。此外，面向对象工具以及库的巨大威力使编程成为一项更使人愉悦的任务。

### 面向对象程序设计方法

(1) 所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。

(2) 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那 28 个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个 子例程或函数。 

(3) 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。 

(4) 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。 

(5) 同一类所有对象都能接收相同的消息。由于类型为 “圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括 “圆”。这一特性称为对象的“可替换性”，是OOP 最重要的概念之一。

### 数据保存

程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据： 

(1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的 程序里找到寄存器存在的任何踪迹。 

(2) 堆栈。驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存 方式，仅次于寄存器。创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存 在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活 性，所以尽管有些Java数据要保存在堆栈里——特别是对象句柄，但Java 对象并不放到其中。

(3) 堆。一种常规用途的内存池（也在 RAM 区域），其中保存Java对象。和堆栈不同，“内存堆”或 “堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要 在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！ 

(4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM 里）。程序运行期间，静态存储的数据将随时等候调用。可用static 关键字指出一个对象的特定元素是静态的。但 Java 对象本身永远都不会置入静态存储空间。 

(5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数 需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。 

(6) 非RAM存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。 其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。Java 1.1 提供了对Lightweight persistence 的支持。

### 面向对象编程

**Java是通过继承，多态，抽象类，接口，静态类等多种方式来实现面向对象编程的**

* 继承

  继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的。

* 多态

  多态是同一个行为具有多个不同表现形式或形态的能力。同一个接口，使用不同的实例而执行不同操作

* 抽象类

  如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

* 接口

  接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。一个实现接口的类，必须实现接口内所描述的所有方法。


